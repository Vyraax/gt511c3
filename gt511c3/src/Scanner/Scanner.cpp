#include "Scanner.h"

#ifdef GT_PLATFORM_WINDOWS
#include <Windows.h>
#endif

#include "Interface/Texture.h"
#include "Core/Utils.h"
#include <string>
#include <thread>
#include <array>
#include <iostream>
#include <chrono>
#include <experimental/filesystem>

#define STB_IMAGE_STATIC
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

using namespace std::chrono_literals;
namespace fs = std::experimental::filesystem;

std::mutex Scanner::mutex = {};

Scanner::Scanner() :
	serial(nullptr),
	port("COM5"),	
	baud_rate(9600),
	timeout(16),
	debug(true),
	tx(0),
	rx(0)
{
}

Scanner::~Scanner()
{
	change_baud_rate(9600);
	Utils::platform_sleep(100);
	serial->setBaudrate(9600);
	Utils::platform_sleep(100);
	serial->close();

	delete serial;
}

bool Scanner::connect()
{
	try {
		serial = new serial::Serial(port, baud_rate);
	}
	catch (std::exception e) {
		std::cout << "Error while opening port " << port << std::endl;
		std::cout << e.what() << std::endl << std::endl;
	}

	bool opened = serial->isOpen();

	if (opened) {
		open(1);
		toggle_led(1);
	}

	return opened;
}

void Scanner::disconnect()
{
	close();
	serial->close();
	//delete device_infos;
}

std::unordered_map<std::string, std::string> Scanner::get_ports_list()
{
	auto devices = serial::list_ports();
	auto it = devices.begin();
	std::unordered_map<std::string, std::string> out = {};

	while (it != devices.end()) {
		serial::PortInfo device = *it++;
		out[device.port] = device.description;
	}

	return out;
}

void Scanner::open(int flags)
{
	this->send_command<CommandPacket>(Command::OPEN, 1);
	auto ack = this->receive_ack();

	if (ack) {
		unsigned char* data = new unsigned char[sizeof DeviceInfoPacket];
		auto succeed = this->receive_data(data, sizeof DeviceInfoPacket);

		device_infos = reinterpret_cast<DeviceInfoPacket*>(data);
	}
}

void Scanner::close() 
{
	toggle_led(0);
	Utils::platform_sleep(100);
	change_baud_rate(9600);
	Utils::platform_sleep(100);
	serial->setBaudrate(9600);
	Utils::platform_sleep(100);

	this->send_command<CommandPacket>(Command::CLOSE);
}

int Scanner::add_user(int flags, int quality)
{
	int index = get_users_count();

	if (index < 0)
		return -1;

	unsigned int max_tries = 10;
	unsigned int tries = 0;

	while (true) {
		this->send_command<CommandPacket>(Command::ENROLL_START, index);
		auto ack = this->receive_ack();

		if (ack)
			break;
		else {
			++tries;

			if (tries >= max_tries)
				return -1;

			Utils::platform_sleep(50);
		}
	}

	std::cout << "Determined new index: " << index << std::endl;

	std::array<unsigned char, 3> steps = { 1, 2, 3 };

	for (auto step : steps) {
		unsigned int count = 0;

		while (!capture_finger(quality)) {
			++count;

			if (count > max_tries)
				return -1;

			Utils::platform_sleep(50);
		}

		count = 0;

		auto callback = [=](unsigned short i) -> bool {
			auto command = Command::ENROLL_1;

			if (i == 1) command = Command::ENROLL_1;
			else if (i == 2) command = Command::ENROLL_2;
			else if (i == 3) command = Command::ENROLL_3;

			std::cout << "Enroll " << i << std::endl;

			this->send_command<CommandPacket>(command);

			return this->receive_ack();
		};

		while (!callback(step)) {
			++count;

			if (count >= max_tries)
				return -1;

			Utils::platform_sleep(50);
		}
	}

	return index;
}

int Scanner::get_users_count()
{
	this->send_command<CommandPacket>(Command::GET_ENROLL_COUNT);
	int param = 0;
	auto ack = this->receive_ack(&param);

	return ack ? param : -1;
}

bool Scanner::user_exists(int flags)
{
	this->send_command<CommandPacket>(Command::CHECK_ENROLLED, flags);
	return this->receive_ack();
}

bool Scanner::delete_user(int flags)
{
	this->send_command<CommandPacket>(Command::DELETE_ID, flags);

	auto filename = std::string("./data/fingerprints/") + std::to_string(flags) + ".bmp";

	if (fs::exists(filename)) {
		fs::remove(filename);
	}

	return this->receive_ack();
}

bool Scanner::delete_all_users()
{
	this->send_command<CommandPacket>(Command::DELETE_ALL);
	return this->receive_ack();
}

bool Scanner::verify_user(int flags)
{
	this->send_command<CommandPacket>(Command::VERIFY, flags);
	return this->receive_ack();
}

int Scanner::identify_user()
{
	this->send_command<CommandPacket>(Command::IDENTIFY);
	int param = 0;

	return this->receive_ack(&param)
		? param
		: -1;
}

bool Scanner::toggle_led(int flags)
{
	this->send_command<CommandPacket>(Command::CMOS_LED, flags);
	return this->receive_ack();
}

bool Scanner::is_finger_pressed()
{
	this->send_command<CommandPacket>(Command::IS_PRESS_FINGER);
	int param = 0;
	auto ack = this->receive_ack(&param);

	if (ack)
		return param == 0;

	return false;
}

bool Scanner::capture_finger(int flags)
{
	this->send_command<CommandPacket>(Command::CAPTURE_FINGER, flags);
	return this->receive_ack();
}

bool Scanner::change_baud_rate(int flags)
{
	this->send_command<CommandPacket>(Command::CHANGE_BAUD_RATE, flags);
	auto ack = this->receive_ack();

	if (ack) {
		std::cout << "Baud rate changed  to: " << std::to_string(flags) << std::endl;
		return true;
	}

	return false;
}

unsigned char* Scanner::get_image()
{
	std::cout << "-----------------------" << std::endl;

	CommandPacket packet;
	packet.start_code1 = START_CODE1;
	packet.start_code2 = START_CODE2;
	packet.device_id = DEVICE_ID;
	packet.parameter = 1;
	packet.command_code = Command::GET_IMAGE;
	packet.checksum = calc_packet_checksum<CommandPacket>(&packet);

	auto d = reinterpret_cast<unsigned char*>(&packet);

	std::cout << "Bytes sent: " << std::endl;

	for (int i = 0; i < PACKET_SIZE; i++) {
		std::cout << HEX(d[i]) << " ";
	}

	std::cout << std::endl;

	size_t w = serial->write(d, PACKET_SIZE);
	std::cout << "Bytes written: " << std::dec << w << std::endl;

	Utils::platform_sleep(100);

	uint8_t* readBuf = new uint8_t[PACKET_SIZE];
	auto r = serial->read(readBuf, PACKET_SIZE);

	std::cout << "Bytes read: " << std::dec << r << std::endl;

	auto res = reinterpret_cast<ResponsePacket*>(readBuf);

	if (res->command_code == Command::ACK) {
		std::cout << "Acknowledge packet received" << std::endl;
		std::cout << "Getting image..." << std::endl;

		Utils::platform_sleep(100);
		change_baud_rate(115200);
		Utils::platform_sleep(100);

		uint8_t* readBuf = new uint8_t[PACKET_IMAGE_SIZE];
		auto r2 = serial->read(readBuf, PACKET_IMAGE_SIZE);

		std::cout << "Bytes read: " << std::dec << r2 << std::endl;
	}
	else {
		std::cout << "Error: " <<
			get_error_code(res->command_code) << " (" << HEX(res->command_code) << ")" <<
			std::endl;
	}

	return nullptr;
}


Texture* Scanner::get_raw_image(const std::string& filename, std::atomic<float>& progress)
{
	std::cout << "-----------------------" << std::endl;
	Utils::platform_sleep(100);
	change_baud_rate(115200);
	Utils::platform_sleep(100);
	serial->setBaudrate(115200);
	Utils::platform_sleep(100);

	CommandPacket packet;
	packet.start_code1 = START_CODE1;
	packet.start_code2 = START_CODE2;
	packet.device_id = DEVICE_ID;
	packet.parameter = 0;
	packet.command_code = Command::GET_RAW_IMAGE;
	packet.checksum = calc_packet_checksum<CommandPacket>(&packet);

	auto d = reinterpret_cast<unsigned char*>(&packet);

	std::cout << "Bytes sent: " << std::endl;

	for (int i = 0; i < PACKET_SIZE; i++)
		std::cout << HEX(d[i]) << " ";

	std::cout << std::endl;
	Utils::platform_sleep(100);
	size_t w = serial->write(d, PACKET_SIZE);
	std::cout << "Bytes written: " << std::dec << w << std::endl;

	uint8_t* readBuf = new uint8_t[PACKET_SIZE];
	auto r = serial->read(readBuf, PACKET_SIZE);
	std::cout << "Bytes read: " << std::dec << r << std::endl;

	auto res = reinterpret_cast<ResponsePacket*>(readBuf);

	Utils::platform_sleep(100);

	if (res->command_code == Command::ACK) {
		std::cout << "Acknowledge packet received" << std::endl;

		unsigned char gbyImgRaw[320 * 240 + 14];
		unsigned char gbyImgRaw2[(240 * 320 / 4) + 6];

		char bitmap[1078] = {
			0x42,0x4D,0x36,0x4F,0x0,0x0,0x0,0x0,0x0,0x0,0x36,0x4,0x0,0x0,

			0x28,0x0,0x0,0x0,0xA0,0x0,0x0,0x0,0x78,0x0,0x0,0x0,0x1,0x0,0x8,
			0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x1,
			0x0,0x2,0x2,0x2,0x0,0x3,0x3,0x3,0x0,0x4,0x4,0x4,0x0,0x5,0x5,0x5,
			0x0,0x6,0x6,0x6,0x0,0x7,0x7,0x7,0x0,0x8,0x8,0x8,0x0,0x9,0x9,0x9,
			0x0,0xA,0xA,0xA,0x0,0xB,0xB,0xB,0x0,0xC,0xC,0xC,0x0,0xD,0xD,0xD,
			0x0,0xE,0xE,0xE,0x0,0xF,0xF,0xF,0x0,0x10,0x10,0x10,0x0,0x11,0x11,
			0x11,0x0,0x12,0x12,0x12,0x0,0x13,0x13,0x13,0x0,0x14,0x14,0x14,0x0,
			0x15,0x15,0x15,0x0,0x16,0x16,0x16,0x0,0x17,0x17,0x17,0x0,0x18,0x18,
			0x18,0x0,0x19,0x19,0x19,0x0,0x1A,0x1A,0x1A,0x0,0x1B,0x1B,0x1B,0x0,
			0x1C,0x1C,0x1C,0x0,0x1D,0x1D,0x1D,0x0,0x1E,0x1E,0x1E,0x0,0x1F,0x1F,
			0x1F,0x0,0x20,0x20,0x20,0x0,0x21,0x21,0x21,0x0,0x22,0x22,0x22,0x0,
			0x23,0x23,0x23,0x0,0x24,0x24,0x24,0x0,0x25,0x25,0x25,0x0,0x26,0x26,
			0x26,0x0,0x27,0x27,0x27,0x0,0x28,0x28,0x28,0x0,0x29,0x29,0x29,0x0,
			0x2A,0x2A,0x2A,0x0,0x2B,0x2B,0x2B,0x0,0x2C,0x2C,0x2C,0x0,0x2D,0x2D,
			0x2D,0x0,0x2E,0x2E,0x2E,0x0,0x2F,0x2F,0x2F,0x0,0x30,0x30,0x30,0x0,
			0x31,0x31,0x31,0x0,0x32,0x32,0x32,0x0,0x33,0x33,0x33,0x0,0x34,0x34,
			0x34,0x0,0x35,0x35,0x35,0x0,0x36,0x36,0x36,0x0,0x37,0x37,0x37,0x0,
			0x38,0x38,0x38,0x0,0x39,0x39,0x39,0x0,0x3A,0x3A,0x3A,0x0,0x3B,0x3B,
			0x3B,0x0,0x3C,0x3C,0x3C,0x0,0x3D,0x3D,0x3D,0x0,0x3E,0x3E,0x3E,0x0,
			0x3F,0x3F,0x3F,0x0,0x40,0x40,0x40,0x0,0x41,0x41,0x41,0x0,0x42,0x42,
			0x42,0x0,0x43,0x43,0x43,0x0,0x44,0x44,0x44,0x0,0x45,0x45,0x45,0x0,
			0x46,0x46,0x46,0x0,0x47,0x47,0x47,0x0,0x48,0x48,0x48,0x0,0x49,0x49,
			0x49,0x0,0x4A,0x4A,0x4A,0x0,0x4B,0x4B,0x4B,0x0,0x4C,0x4C,0x4C,0x0,
			0x4D,0x4D,0x4D,0x0,0x4E,0x4E,0x4E,0x0,0x4F,0x4F,0x4F,0x0,0x50,0x50,
			0x50,0x0,0x51,0x51,0x51,0x0,0x52,0x52,0x52,0x0,0x53,0x53,0x53,0x0,
			0x54,0x54,0x54,0x0,0x55,0x55,0x55,0x0,0x56,0x56,0x56,0x0,0x57,0x57,
			0x57,0x0,0x58,0x58,0x58,0x0,0x59,0x59,0x59,0x0,0x5A,0x5A,0x5A,0x0,
			0x5B,0x5B,0x5B,0x0,0x5C,0x5C,0x5C,0x0,0x5D,0x5D,0x5D,0x0,0x5E,0x5E,
			0x5E,0x0,0x5F,0x5F,0x5F,0x0,0x60,0x60,0x60,0x0,0x61,0x61,0x61,0x0,
			0x62,0x62,0x62,0x0,0x63,0x63,0x63,0x0,0x64,0x64,0x64,0x0,0x65,0x65,
			0x65,0x0,0x66,0x66,0x66,0x0,0x67,0x67,0x67,0x0,0x68,0x68,0x68,0x0,
			0x69,0x69,0x69,0x0,0x6A,0x6A,0x6A,0x0,0x6B,0x6B,0x6B,0x0,0x6C,0x6C,
			0x6C,0x0,0x6D,0x6D,0x6D,0x0,0x6E,0x6E,0x6E,0x0,0x6F,0x6F,0x6F,0x0,
			0x70,0x70,0x70,0x0,0x71,0x71,0x71,0x0,0x72,0x72,0x72,0x0,0x73,0x73,
			0x73,0x0,0x74,0x74,0x74,0x0,0x75,0x75,0x75,0x0,0x76,0x76,0x76,0x0,
			0x77,0x77,0x77,0x0,0x78,0x78,0x78,0x0,0x79,0x79,0x79,0x0,0x7A,0x7A,
			0x7A,0x0,0x7B,0x7B,0x7B,0x0,0x7C,0x7C,0x7C,0x0,0x7D,0x7D,0x7D,0x0,
			0x7E,0x7E,0x7E,0x0,0x7F,0x7F,0x7F,0x0,0x80,0x80,0x80,0x0,0x81,0x81,
			0x81,0x0,0x82,0x82,0x82,0x0,0x83,0x83,0x83,0x0,0x84,0x84,0x84,0x0,
			0x85,0x85,0x85,0x0,0x86,0x86,0x86,0x0,0x87,0x87,0x87,0x0,0x88,0x88,
			0x88,0x0,0x89,0x89,0x89,0x0,0x8A,0x8A,0x8A,0x0,0x8B,0x8B,0x8B,0x0,
			0x8C,0x8C,0x8C,0x0,0x8D,0x8D,0x8D,0x0,0x8E,0x8E,0x8E,0x0,0x8F,0x8F,
			0x8F,0x0,0x90,0x90,0x90,0x0,0x91,0x91,0x91,0x0,0x92,0x92,0x92,0x0,
			0x93,0x93,0x93,0x0,0x94,0x94,0x94,0x0,0x95,0x95,0x95,0x0,0x96,0x96,
			0x96,0x0,0x97,0x97,0x97,0x0,0x98,0x98,0x98,0x0,0x99,0x99,0x99,0x0,
			0x9A,0x9A,0x9A,0x0,0x9B,0x9B,0x9B,0x0,0x9C,0x9C,0x9C,0x0,0x9D,0x9D,
			0x9D,0x0,0x9E,0x9E,0x9E,0x0,0x9F,0x9F,0x9F,0x0,0xA0,0xA0,0xA0,0x0,
			0xA1,0xA1,0xA1,0x0,0xA2,0xA2,0xA2,0x0,0xA3,0xA3,0xA3,0x0,0xA4,0xA4,
			0xA4,0x0,0xA5,0xA5,0xA5,0x0,0xA6,0xA6,0xA6,0x0,0xA7,0xA7,0xA7,0x0,
			0xA8,0xA8,0xA8,0x0,0xA9,0xA9,0xA9,0x0,0xAA,0xAA,0xAA,0x0,0xAB,0xAB,
			0xAB,0x0,0xAC,0xAC,0xAC,0x0,0xAD,0xAD,0xAD,0x0,0xAE,0xAE,0xAE,0x0,
			0xAF,0xAF,0xAF,0x0,0xB0,0xB0,0xB0,0x0,0xB1,0xB1,0xB1,0x0,0xB2,0xB2,
			0xB2,0x0,0xB3,0xB3,0xB3,0x0,0xB4,0xB4,0xB4,0x0,0xB5,0xB5,0xB5,0x0,
			0xB6,0xB6,0xB6,0x0,0xB7,0xB7,0xB7,0x0,0xB8,0xB8,0xB8,0x0,0xB9,0xB9,
			0xB9,0x0,0xBA,0xBA,0xBA,0x0,0xBB,0xBB,0xBB,0x0,0xBC,0xBC,0xBC,0x0,
			0xBD,0xBD,0xBD,0x0,0xBE,0xBE,0xBE,0x0,0xBF,0xBF,0xBF,0x0,0xC0,0xC0,
			0xC0,0x0,0xC1,0xC1,0xC1,0x0,0xC2,0xC2,0xC2,0x0,0xC3,0xC3,0xC3,0x0,
			0xC4,0xC4,0xC4,0x0,0xC5,0xC5,0xC5,0x0,0xC6,0xC6,0xC6,0x0,0xC7,0xC7,
			0xC7,0x0,0xC8,0xC8,0xC8,0x0,0xC9,0xC9,0xC9,0x0,0xCA,0xCA,0xCA,0x0,
			0xCB,0xCB,0xCB,0x0,0xCC,0xCC,0xCC,0x0,0xCD,0xCD,0xCD,0x0,0xCE,0xCE,
			0xCE,0x0,0xCF,0xCF,0xCF,0x0,0xD0,0xD0,0xD0,0x0,0xD1,0xD1,0xD1,0x0,
			0xD2,0xD2,0xD2,0x0,0xD3,0xD3,0xD3,0x0,0xD4,0xD4,0xD4,0x0,0xD5,0xD5,
			0xD5,0x0,0xD6,0xD6,0xD6,0x0,0xD7,0xD7,0xD7,0x0,0xD8,0xD8,0xD8,0x0,
			0xD9,0xD9,0xD9,0x0,0xDA,0xDA,0xDA,0x0,0xDB,0xDB,0xDB,0x0,0xDC,0xDC,
			0xDC,0x0,0xDD,0xDD,0xDD,0x0,0xDE,0xDE,0xDE,0x0,0xDF,0xDF,0xDF,0x0,
			0xE0,0xE0,0xE0,0x0,0xE1,0xE1,0xE1,0x0,0xE2,0xE2,0xE2,0x0,0xE3,0xE3,
			0xE3,0x0,0xE4,0xE4,0xE4,0x0,0xE5,0xE5,0xE5,0x0,0xE6,0xE6,0xE6,0x0,
			0xE7,0xE7,0xE7,0x0,0xE8,0xE8,0xE8,0x0,0xE9,0xE9,0xE9,0x0,0xEA,0xEA,
			0xEA,0x0,0xEB,0xEB,0xEB,0x0,0xEC,0xEC,0xEC,0x0,0xED,0xED,0xED,0x0,
			0xEE,0xEE,0xEE,0x0,0xEF,0xEF,0xEF,0x0,0xF0,0xF0,0xF0,0x0,0xF1,0xF1,
			0xF1,0x0,0xF2,0xF2,0xF2,0x0,0xF3,0xF3,0xF3,0x0,0xF4,0xF4,0xF4,0x0,
			0xF5,0xF5,0xF5,0x0,0xF6,0xF6,0xF6,0x0,0xF7,0xF7,0xF7,0x0,0xF8,0xF8,
			0xF8,0x0,0xF9,0xF9,0xF9,0x0,0xFA,0xFA,0xFA,0x0,0xFB,0xFB,0xFB,0x0,0xFC,0xFC
		};

		std::cout << "Getting raw image..." << std::endl;

		size_t total = 0;
		size_t max = (240 * 320 / 4) + 6;
		unsigned char tmpBuf[33];

		for (size_t i = 0; i < max; i += 33)
		{
			std::this_thread::sleep_for(0.0001s);

			auto bytes = serial->read(tmpBuf, 33);
			std::memcpy(gbyImgRaw2 + i, tmpBuf, 33);
			total += bytes;
			
			progress = ((float)total / (float)max) * 100.0f;
		}

		unsigned char pBuf[240 * 320 / 4];
		std::memcpy(pBuf, gbyImgRaw2 + 4, sizeof(pBuf));

		std::cout << "Image bytes read: " << std::dec << int(total) << std::endl;
		std::memset(gbyImgRaw, 66, sizeof(gbyImgRaw));

		int i, j;
		for (i = 0; i < 120; i++) {
			for (j = 0; j < 160; j++) {
				gbyImgRaw[320 * (2 * i + 0) + (2 * j + 0)] = pBuf[i * 160 + j];
				gbyImgRaw[320 * (2 * i + 0) + (2 * j + 1)] = pBuf[i * 160 + j];
				gbyImgRaw[320 * (2 * i + 1) + (2 * j + 0)] = pBuf[i * 160 + j];
				gbyImgRaw[320 * (2 * i + 1) + (2 * j + 1)] = pBuf[i * 160 + j];
			}
		}

		unsigned char* final = new unsigned char[sizeof bitmap + sizeof gbyImgRaw2];

		std::memcpy(final, bitmap, sizeof bitmap);
		std::memcpy(final + sizeof bitmap, gbyImgRaw2, sizeof gbyImgRaw2);

		//auto cat = (unsigned char*)strcat((char*)&bitmap, (char*)gbyImgRaw);

		for (int i = 0; i < 14; i++)
			std::cout << HEX(final[i]) << " ";

		std::cout << std::endl;

		if (!fs::is_directory("./data/fingerprints") || !fs::exists("./data/fingerprints")) {
			fs::create_directory("./data/fingerprints"); // create src folder
		}

		std::ofstream stream(std::string("./data/fingerprints/") + filename + ".bmp", std::ios::binary);

		for (int i = 0; i < 20278; i++)
			stream << final[i];

		stream.close();

		change_baud_rate(9600);
		Utils::platform_sleep(100);
		serial->setBaudrate(9600);
		Utils::platform_sleep(100);

		return nullptr;
	} 
	else {
		std::cout << "Error: " <<
			get_error_code(res->command_code) << " (" << HEX(res->command_code) << ")" <<
			std::endl;
	}

	change_baud_rate(9600);
	Utils::platform_sleep(100);
	serial->setBaudrate(9600);
	Utils::platform_sleep(100);

	serial->flush();
	std::terminate();

	return nullptr;
}

template<typename T>
size_t Scanner::send_command(Command command, int param)
{
	if (serial->isOpen()) {
		std::cout << "-----------------------" << std::endl;
		std::cout << "SENDING: " << command_to_string(command) << std::endl;

		unsigned char* packet = create_packet<T>(command, param);
		size_t bytes = serial->write(packet, PACKET_SIZE);
		tx = bytes;

		if (debug) {
			std::cout << "Size: " << std::dec << bytes << std::endl;
			std::cout << "Data: ";

			for (int i = 0; i < PACKET_SIZE; i++)
				std::cout << HEX(packet[i]) << " ";

			std::cout << std::endl;
		}

		return bytes;
	}

	return 0;
}

bool Scanner::receive_ack(int* param)
{
	std::cout << "-----------------------" << std::endl;
	std::cout << "ACK: " << std::endl;

	auto data = new uint8_t[PACKET_SIZE];
	size_t bytes = serial->read(data, PACKET_SIZE);
	rx = bytes;

	std::cout << "Available: " << std::dec << serial->available() << std::endl;
	
	auto response = reinterpret_cast<ResponsePacket*>(data);

	if (bytes != PACKET_SIZE) {
		std::cout << "Error while receiving ack, bytes doesn't match. Received " << bytes << " bytes." << std::endl;
		return false;
	}

	if (param != nullptr) {
		if (response->start_code1 != START_CODE1 || response->start_code2 != START_CODE2) {
			std::cout << "Error while receiving ack, can't decode packet header. 1: "
				<< HEX(response->start_code1) << ", 2: " << HEX(response->start_code2) << std::endl;
			//return false;
		}
	}

	if (response->command_code == Command::ACK) {
		if (param != nullptr)
			*param = response->parameter;

		return true;
	}
	else if (response->command_code == Command::NACK) {
		std::cout << "Error: " << get_error_code(response->parameter) << std::endl;
	}

	return false;
}

int Scanner::receive_data(unsigned char* data, int length)
{
	auto size = length
		+ PACKET_HEADER_SIZE
		+ PACKET_DEVICE_ID_SIZE
		+ PACKET_CHECKSUM_SIZE;

	uint8_t* buffer = new uint8_t[size];
	size_t bytes = serial->read(buffer, size);
	rx = bytes;

	if (bytes != size) {
		//delete buffer;
		std::cout << "Error: Received bytes size is different from expected. Received: " << bytes << " bytes." << std::endl;
		return 0;
	}

	uint8_t* header = new uint8_t[4];
	std::memcpy(header, buffer, PACKET_HEADER_SIZE + PACKET_DEVICE_ID_SIZE);
	std::memcpy(data, buffer + PACKET_HEADER_SIZE + PACKET_DEVICE_ID_SIZE, size);

	//if (buffer)
	//	delete buffer;

	if (header[0] != START_CODE3 || header[1] != START_CODE4) {
		std::cout << "Error: Can't decode packet, not recognized as data packet." << std::endl;
		return 0;
	}

	//auto response = reinterpret_cast<T*>(data);

	if (debug) {
		std::cout << "-----------------------" << std::endl;
		std::cout << "RECEIVED: "; /* << command_to_string((Command)((ResponsePacket*)response)->command_code) << std::endl;*/
	
		std::cout << "Size: " << std::dec << bytes << std::endl;
		std::cout << "Data: ";

		for (int i = 0; i < bytes; i++)
			std::cout << HEX(data[i]) << " ";

		std::cout << std::endl;
	}

	return 0;
}
